# Form implementation generated from reading ui file '.\remote_controller.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets

# Imports
import queue
import rsa
import socket
import time
import messages_pb2 as messages
from google.protobuf.message import DecodeError
from datetime import timedelta
from datetime import datetime
from day_schedule import Ui_DaySchedule

# Connection variables
HOST = '192.168.1.178'
PORT = 50007
VERSION = '0.2'
ABOUT_STR = 'Remote Controller v' + VERSION + ' created by Pablo Garcia Beltran (pablopgb.pgb@gmail.com)'
DEMO_MODE = False

# Weekday index to string
day_map = {
    0: 'Monday',
    1: 'Tuesday',
    2: 'Wednesday',
    3: 'Thursday',
    4: 'Friday',
    5: 'Saturday',
    6: 'Sunday'
}

# State to text map
STATE_TO_TEXT = {
    messages.STATE.DEV_ACTIVE: 'ACTIVE',
    messages.STATE.DEV_INACTIVE: 'INACTIVE',
    messages.STATE.DEV_UNINHIBITED: 'UNINHIBITED',
    messages.STATE.DEV_INHIBITED: 'INHIBITED'
}

# Unit to seconds multiplier
UNIT_TO_SECS = {
    'sec': 1,
    'min': 60,
    'hour': 3600,
    'day': 86400
}

def get_all_instances_on_day ( date_to_check, event ):
    dt = datetime.fromtimestamp( event.timestamp.seconds )
    dt_date = dt.date()
    date_to_check_as_dt = datetime.combine( date_to_check, datetime.min.time() )
    td_period = timedelta( seconds=event.period.seconds )
    one_day = timedelta( days=1 )
    td_0 = timedelta()
    events_out = []
    if date_to_check == dt_date:
        if td_0 != td_period:
            num_times = 1 + ( ( ( date_to_check_as_dt + one_day ) - dt ) // td_period )
        else:
            num_times = 1
        for i in range( num_times ):
            new_event = messages.container.SCHEDULED_DEVICE_EVENT()
            new_event.CopyFrom( event )
            new_event.timestamp.seconds = event.timestamp.seconds + ( i * event.period.seconds )
            events_out.append( new_event )
    else:
        # Fast forward to first occurrence in day
        dt = date_to_check_as_dt - ( ( date_to_check_as_dt - dt ) % td_period ) + td_period
        if td_0 != td_period:
            num_times = 1 + ( ( ( date_to_check_as_dt + one_day ) - dt ) // td_period )
        else:
            num_times = 1
        for i in range( num_times ):
            new_event = messages.container.SCHEDULED_DEVICE_EVENT()
            new_event.CopyFrom( event )
            new_event.timestamp.seconds = int( dt.timestamp() ) + ( i * event.period.seconds )
            events_out.append( new_event )
    return events_out

def is_event_scheduled ( date_to_check, schedule ):
    # Is date in the past?
    dt_today = datetime.today()
    date_today = dt_today.date()
    if date_to_check < date_today:
        return ( [], False )

    times = []
    origin = False
    for event in schedule:
        dt = datetime.fromtimestamp( event.timestamp.seconds )
        dt_date = dt.date()
        td_period = timedelta( seconds=event.period.seconds )
        # Is this event not expired?
        if dt >= dt_today:
            td_0 = timedelta()
            # Is this event on the date to check?
            if date_to_check == dt_date:
                times.extend( get_all_instances_on_day( date_to_check, event ) )
                origin = True
            elif date_to_check > dt_date and td_period > td_0:
                td_between = date_to_check - dt_date
                # Check if time between events a multiple of the period
                if td_between % td_period == td_0:
                    times.extend( get_all_instances_on_day( date_to_check, event ) )

    return ( times, origin )

def are_schedules_same ( schedule_a, schedule_b ):
    if ( schedule_a is None and schedule_b is not None ) or ( schedule_a is not None and schedule_b is None ):
        return False
    if schedule_a is None and schedule_b is None:
        return True
    for e_a, e_b in zip( schedule_a, schedule_b ):
        if e_a.timestamp.seconds != e_b.timestamp.seconds:
            return False
        elif e_a.duration.seconds != e_b.duration.seconds:
            return False
        elif e_a.period.seconds != e_b.period.seconds:
            return False
    return len( schedule_a ) == len( schedule_b )


############################################################################################
# Thread that handles sending
class Sender ( QtCore.QThread ):
    lost_conn = QtCore.pyqtSignal()

    def __init__ ( self, s, s_lock, q_out, q_out_lock ):
        QtCore.QThread.__init__( self )
        self.s = s
        self.s_lock = s_lock
        self.q_out = q_out
        self.q_out_lock = q_out_lock

    def run ( self ):
        print( 'Sender thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            self.q_out_lock.lock()
            if not self.q_out.empty():
                container = self.q_out.get()
                self.q_out_lock.unlock()
                data = container.SerializeToString()
                try:
                    self.s_lock.lock()
                    self.s.sendall( data )
                    time.sleep( 0.10 )

                except ( ConnectionAbortedError, ConnectionResetError, ConnectionRefusedError ):
                    self.lost_conn.emit()
                    break

                finally:
                    self.s_lock.unlock()
            else:
                self.q_out_lock.unlock()

        print( 'Sender thread shutting down' )
############################################################################################


############################################################################################
# Thread that handles receiving
class Receiver ( QtCore.QThread ):
    lost_conn = QtCore.pyqtSignal()
    server_alive = QtCore.pyqtSignal()

    def __init__ ( self, s, s_lock, q_in, q_in_lock ):
        QtCore.QThread.__init__( self )
        self.s = s
        self.s_lock = s_lock
        self.q_in = q_in
        self.q_in_lock = q_in_lock

    def run ( self ):
        print( 'Receiver thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            try:
                self.s_lock.lock()
                data = self.s.recv( 1024 )
                if data:
                    try:
                        container = messages.container()
                        container.ParseFromString( data )
                        self.server_alive.emit()
                        self.q_in_lock.lock()
                        self.q_in.put( container )
                        self.q_in_lock.unlock()

                    except DecodeError:
                        print( 'Was not able to parse message!' )

            except BlockingIOError:
                continue

            except ( ConnectionAbortedError, ConnectionResetError, ConnectionRefusedError ):
                self.lost_conn.emit()
                break

            finally:
                self.s_lock.unlock()

        print( 'Receiver thread shutting down' )
############################################################################################


#######################################################################################################
# Create QtThread that will update the GUI
class UpdateMonitor ( QtCore.QThread ):
    device_update_signal = QtCore.pyqtSignal( [ messages.container.DEVICE_STATES ] )
    print_info_signal = QtCore.pyqtSignal( [ str ] )
    save_schedule = QtCore.pyqtSignal( [ list ] )
    save_key = QtCore.pyqtSignal( [ bytes ] )
    authenticated = QtCore.pyqtSignal( [ bool ] )

    def __init__ ( self, q_in, q_in_lock ):
        QtCore.QThread.__init__( self )
        self.q_in = q_in
        self.q_in_lock = q_in_lock

    def run ( self ):
        print( 'Updater monitor thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            self.q_in_lock.lock()
            if not self.q_in.empty():
                container = self.q_in.get()
                self.q_in_lock.unlock()
                
                if container.HasField( 'states' ):
                    self.device_update_signal.emit( container.states )

                elif container.HasField( 'events' ):
                    schedule = [ x for x in container.events.event ]
                    schedule.sort( key=lambda x: x.timestamp.seconds )
                    self.save_schedule.emit( schedule )

                elif container.HasField( 'no_events' ):
                    self.save_schedule.emit( [] )

                elif container.HasField( 'logs' ):
                    if container.logs == '':
                        self.print_info_signal.emit( 'No logs!' )
                    else:
                        self.print_info_signal.emit( 'LOGS:' )
                        self.print_info_signal.emit( container.logs[ :-1 ] )

                elif container.HasField( 'info' ):
                    self.print_info_signal.emit( container.info )

                elif container.HasField( 'pubkey' ):
                    self.save_key.emit( container.pubkey )

                elif container.HasField( 'auth' ):
                    self.authenticated.emit( container.auth )

            else:
                self.q_in_lock.unlock()

        print( 'The update monitor thread is shutting down' )
#######################################################################################################


############################################################
# Clickable label, used for secret demo mode sensor toggling
class QClickableLabel( QtWidgets.QLabel ):
    clicked = QtCore.pyqtSignal( [ str ] )
    device_name = ''

    def __init__ ( self, parent ):
        QtWidgets.QLabel.__init__( self, parent )

    def set_device_name ( self, device_name ):
        self.device_name = device_name

    def mousePressEvent( self, event ):
        self.clicked.emit( self.device_name )
############################################################


#########################################################################################################
# Table model to use in day schedule
class TableModel( QtCore.QAbstractTableModel ):
    def __init__ ( self, dt, schedule ):
        QtCore.QAbstractTableModel.__init__( self )
        self.dt = dt
        self.schedule = schedule.copy()
        self.table = []
        dt_today = datetime.today()
        dt_clicked = self.dt
        dt_clicked_date = dt_clicked.date()
        self.table = list( [ [ datetime.fromtimestamp( x.timestamp.seconds ).time(), x.duration.seconds, x.period.seconds, ( 1 if x.state.state == messages.STATE.DEV_ACTIVE else 0 ) ] for x in is_event_scheduled( dt_clicked_date, self.schedule )[0] ] )

        self.table.sort()

        self.horizontalHeaders = [''] * 4
        self.setHeaderData( 0, QtCore.Qt.Orientation.Horizontal, 'TIME' )
        self.setHeaderData( 1, QtCore.Qt.Orientation.Horizontal, 'DURATION' )
        self.setHeaderData( 2, QtCore.Qt.Orientation.Horizontal, 'PERIOD' )
        self.setHeaderData( 3, QtCore.Qt.Orientation.Horizontal, 'STATE' )

    def data ( self, index, role ):
        if role == QtCore.Qt.ItemDataRole.DisplayRole:
            if index.column() == 0:
                return str( self.table[ index.row() ][ index.column() ].strftime( '%H:%M' ) )
            elif index.column() == 1:
                return str( timedelta( seconds=self.table[ index.row() ][ index.column() ] ) )
            elif index.column() == 2:
                return str( timedelta( seconds=self.table[ index.row() ][ index.column() ] ) )
            elif index.column() == 3:
                return str( 'ACTIVE' if self.table[ index.row() ][ index.column() ] == 1 else 'INHIBITED' )
            else:
                return str( self.table[ index.row() ][ index.column() ] )
        elif role == QtCore.Qt.ItemDataRole.EditRole:
            return self.table[ index.row() ][ index.column() ]

    def rowCount( self, index ):
        return len( self.table ) if self.table else 0

    def columnCount( self, index ):
        return len( self.table[0] ) if self.table else 0

    def setHeaderData(self, section, orientation, data, role=QtCore.Qt.ItemDataRole.EditRole):
        if orientation == QtCore.Qt.Orientation.Horizontal and role in (QtCore.Qt.ItemDataRole.DisplayRole, QtCore.Qt.ItemDataRole.EditRole):
            try:
                self.horizontalHeaders[section] = data
                return True
            except:
                return False
        return super().setHeaderData(section, orientation, data, role)

    def headerData(self, section, orientation, role=QtCore.Qt.ItemDataRole.DisplayRole):
        if orientation == QtCore.Qt.Orientation.Horizontal and role == QtCore.Qt.ItemDataRole.DisplayRole:
            try:
                return self.horizontalHeaders[section]
            except:
                pass
        return super().headerData(section, orientation, role)
#########################################################################################################


################################################################################################
# Wrap day schedule
class DaySchedule ( QtWidgets.QDialog ):
    send_signal = QtCore.pyqtSignal( [ messages.container ] )
    print_info_signal = QtCore.pyqtSignal( [ str ] )
    schedule = []
    device_name = ''

    def __init__ ( self, parent=None, schedule=None, dt=None, device_name=None ):
        QtWidgets.QDialog.__init__( self, parent )
        self.ui = Ui_DaySchedule()
        self.ui.setupUi( self )
        self.schedule = schedule.copy()
        self.dt = dt
        self.device_name = device_name
        self.model = TableModel( self.dt, self.schedule )
        self.ui.tv_day_sched.setModel( self.model )
        self.ui.tv_day_sched.doubleClicked.connect( self.copy_from_cell )
        self.ui.btn_sched.clicked.connect( self.schedule_event )
        self.ui.btn_unsched.clicked.connect( self.unschedule_event )

    def schedule_event ( self ):
        period = self.ui.sb_period.value() * UNIT_TO_SECS[ self.ui.cb_period.currentText() ]
        duration = self.ui.sb_dur.value() * UNIT_TO_SECS[ self.ui.cb_dur.currentText() ]
        if period > duration or period == 0:
            time = self.ui.te_tod.time()
            dt = datetime( year=self.dt.year, month=self.dt.month, day=self.dt.day, hour=time.hour(), minute=time.minute() )
            container = messages.container()
            container.set_event.timestamp.seconds = int( dt.timestamp() )
            container.set_event.duration.seconds = duration
            container.set_event.period.seconds = period
            container.set_event.state.device_name = self.device_name
            if self.ui.rb_activate.isChecked(): container.set_event.state.state = messages.STATE.DEV_ACTIVE
            if self.ui.rb_inhibit.isChecked(): container.set_event.state.state = messages.STATE.DEV_INHIBITED
            container.set_event.state.is_output = True
            self.send_signal.emit( container )
            container = messages.container()
            container.get_events = self.device_name
            self.send_signal.emit( container )
        else:
            self.print_info_signal.emit( 'The period must be greater than the duration, failed to schedule event!' )

    def unschedule_event ( self ):
        period = self.ui.sb_period.value() * UNIT_TO_SECS[ self.ui.cb_period.currentText() ]
        duration = self.ui.sb_dur.value() * UNIT_TO_SECS[ self.ui.cb_dur.currentText() ]
        time = self.ui.te_tod.time()
        dt = datetime( year=self.dt.year, month=self.dt.month, day=self.dt.day, hour=time.hour(), minute=time.minute() )
        container = messages.container()
        container.cancel_event.timestamp.seconds = int( dt.timestamp() )
        container.cancel_event.duration.seconds = duration
        container.cancel_event.period.seconds = period
        container.cancel_event.state.device_name = self.device_name
        if self.ui.rb_activate.isChecked(): container.cancel_event.state.state = messages.STATE.DEV_ACTIVE
        if self.ui.rb_inhibit.isChecked(): container.cancel_event.state.state = messages.STATE.DEV_INHIBITED
        container.cancel_event.state.is_output = True
        self.send_signal.emit( container )
        container = messages.container()
        container.get_events = self.device_name
        self.send_signal.emit( container )

    def set_schedule ( self, schedule, device_name ):
        self.schedule = schedule.copy()
        self.device_name = device_name
        self.model = TableModel( self.dt, self.schedule )
        self.ui.tv_day_sched.setModel( self.model )
        self.update()

    def set_device_name ( self, device_name ):
        self.device_name = device_name

    def copy_from_cell ( self, index ):
        time = self.model.table[ index.row() ][ 0 ]
        time = QtCore.QTime( time.hour, time.minute )
        self.ui.te_tod.setTime( time )
        dur = self.model.table[ index.row() ][ 1 ]
        if dur % 3600 == 0:
            self.ui.sb_dur.setValue( dur // 3600 )
            self.ui.cb_dur.setCurrentText( 'hour' )
        elif dur % 60 == 0:
            self.ui.sb_dur.setValue( dur // 60 )
            self.ui.cb_dur.setCurrentText( 'min' )
        else:
            self.ui.sb_dur.setValue( dur )
            self.ui.cb_dur.setCurrentText( 'sec' )
        period = self.model.table[ index.row() ][ 2 ]
        if period % 86400 == 0:
            self.ui.sb_period.setValue( period // 86400 )
            self.ui.cb_period.setCurrentText( 'day' )
        elif period % 3600 == 0:
            self.ui.sb_period.setValue( period // 3600 )
            self.ui.cb_period.setCurrentText( 'hour' )
        elif period % 60 == 0:
            self.ui.sb_period.setValue( period // 60 )
            self.ui.cb_period.setCurrentText( 'min' )
        else:
            self.ui.sb_period.setValue( period )
            self.ui.cb_period.setCurrentText( 'sec' )
        active_state = ( self.model.table[ index.row() ][ 3 ] == 1 )
        if active_state:
            self.ui.rb_activate.setChecked( True )
        else:
            self.ui.rb_inhibit.setChecked( True )
################################################################################################


############################################################################################
# Paintable label, used for painting days that have events
class QPaintableCalendarWidget( QtWidgets.QCalendarWidget ):
    print_info_signal = QtCore.pyqtSignal( [ str ] )
    schedule = []
    device_name = ''

    def __init__ ( self, parent ):
        QtWidgets.QCalendarWidget.__init__( self, parent )

    def set_schedule ( self, schedule, device_name ):
        self.schedule = schedule.copy()
        self.device_name = device_name
        self.updateCells()

    def set_device_name ( self, device_name ):
        self.device_name = device_name

    def paintCell ( self, painter, rect, date ):
        dt_today = datetime.today()
        dt_painting = datetime( year=date.year(), month=date.month(), day=date.day() )
        dt_painting_date = dt_painting.date()
        super().paintCell( painter, rect, date )
        bg_color = QtGui.QColor( 'blue' )
        bg_color.setAlpha( 64 )
        bg_color_dark = QtGui.QColor( 'darkBlue' )
        bg_color_dark.setAlpha( 128 )
        found_events, origin = is_event_scheduled( dt_painting_date, self.schedule )
        if found_events:
            painter.save()
            painter.fillRect( rect, bg_color_dark if origin else bg_color )
            font = painter.font()
            font.setPointSize( 5 * font.pointSize() // 6 )
            font.setBold( True )
            font.setItalic( True )
            painter.setFont( font )
            painter.drawText( rect, 0, 'x' + str( len( found_events ) ) )
            painter.restore()
############################################################################################


class Ui_MainWindow(object):
    def setupUi(self, MainWindow, demo_mode):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(650, 800)
        MainWindow.setTabShape(QtWidgets.QTabWidget.TabShape.Triangular)
        MainWindow.setUnifiedTitleAndToolBarOnMac(True)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_4.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetDefaultConstraint)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.widget_controls = QtWidgets.QWidget(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_controls.sizePolicy().hasHeightForWidth())
        self.widget_controls.setSizePolicy(sizePolicy)
        self.widget_controls.setObjectName("widget_controls")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.widget_controls)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.gb_connection = QtWidgets.QGroupBox(parent=self.widget_controls)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.gb_connection.sizePolicy().hasHeightForWidth())
        self.gb_connection.setSizePolicy(sizePolicy)
        self.gb_connection.setObjectName("gb_connection")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.gb_connection)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.lbl_port = QtWidgets.QLabel(parent=self.gb_connection)
        self.lbl_port.setObjectName("lbl_port")
        self.gridLayout_2.addWidget(self.lbl_port, 2, 1, 1, 1)
        self.txt_host = QtWidgets.QLineEdit(parent=self.gb_connection)
        self.txt_host.setMaximumSize(QtCore.QSize(100, 16777215))
        self.txt_host.setText("")
        self.txt_host.setObjectName("txt_host")
        self.gridLayout_2.addWidget(self.txt_host, 0, 2, 1, 1)
        self.btn_connect = QtWidgets.QPushButton(parent=self.gb_connection)
        self.btn_connect.setEnabled(True)
        self.btn_connect.setObjectName("btn_connect")
        self.gridLayout_2.addWidget(self.btn_connect, 4, 1, 1, 2)
        self.txt_port = QtWidgets.QLineEdit(parent=self.gb_connection)
        self.txt_port.setMaximumSize(QtCore.QSize(100, 16777215))
        self.txt_port.setObjectName("txt_port")
        self.gridLayout_2.addWidget(self.txt_port, 2, 2, 1, 1)
        self.lbl_host = QtWidgets.QLabel(parent=self.gb_connection)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lbl_host.sizePolicy().hasHeightForWidth())
        self.lbl_host.setSizePolicy(sizePolicy)
        self.lbl_host.setObjectName("lbl_host")
        self.gridLayout_2.addWidget(self.lbl_host, 0, 1, 1, 1)
        self.lbl_pswd = QtWidgets.QLabel(parent=self.gb_connection)
        self.lbl_pswd.setObjectName("lbl_pswd")
        self.gridLayout_2.addWidget(self.lbl_pswd, 3, 1, 1, 1)
        self.txt_pswd = QtWidgets.QLineEdit(parent=self.gb_connection)
        self.txt_pswd.setMaximumSize(QtCore.QSize(100, 16777215))
        self.txt_pswd.setObjectName("txt_pswd")
        self.gridLayout_2.addWidget(self.txt_pswd, 3, 2, 1, 1)
        self.verticalLayout_3.addWidget(self.gb_connection)
        self.gb_controls = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_controls.setObjectName("gb_controls")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.gb_controls)
        self.verticalLayout_2.setContentsMargins(-1, 0, -1, -1)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        # ADD HIDDEN RADIO BUTTONS HERE, UP TO 28 POSSIBLE GPIO PINS
        self.rbs_outputs = []
        for i in range( 28 ):
            self.rbs_outputs.append( QtWidgets.QRadioButton(parent=self.gb_controls) )
            self.rbs_outputs[ i ].setObjectName("rb_output_" + str( i ))
            self.rbs_outputs[ i ].setText("Output " + str( i ))
            self.rbs_outputs[ i ].hide()
            self.verticalLayout_2.addWidget(self.rbs_outputs[ i ])
        self.gb_dur = QtWidgets.QGroupBox(parent=self.gb_controls)
        self.gb_dur.setObjectName("gb_dur")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.gb_dur)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.sb_dur = QtWidgets.QSpinBox(parent=self.gb_dur)
        self.sb_dur.setMaximumSize(QtCore.QSize(50, 16777215))
        self.sb_dur.setMinimum(1)
        self.sb_dur.setMaximum(999999999)
        self.sb_dur.setObjectName("sb_dur")
        self.horizontalLayout.addWidget(self.sb_dur)
        self.cmb_dur = QtWidgets.QComboBox(parent=self.gb_dur)
        self.cmb_dur.setMaximumSize(QtCore.QSize(50, 16777215))
        self.cmb_dur.setObjectName("cmb_dur")
        self.cmb_dur.addItems( [ 'hour', 'min', 'sec' ] )
        self.cmb_dur.setCurrentText("min")
        self.horizontalLayout.addWidget(self.cmb_dur)
        self.cb_dur = QtWidgets.QCheckBox(parent=self.gb_dur)
        self.cb_dur.setText("")
        self.cb_dur.setChecked(False)
        self.cb_dur.setObjectName("cb_dur")
        self.horizontalLayout.addWidget(self.cb_dur)
        self.verticalLayout_2.addWidget(self.gb_dur)
        self.btn_activate = QtWidgets.QPushButton(parent=self.gb_controls)
        self.btn_activate.setObjectName("btn_activate")
        self.verticalLayout_2.addWidget(self.btn_activate)
        self.btn_deactivate = QtWidgets.QPushButton(parent=self.gb_controls)
        self.btn_deactivate.setObjectName("btn_deactivate")
        self.verticalLayout_2.addWidget(self.btn_deactivate)
        self.btn_uninhib = QtWidgets.QPushButton(parent=self.gb_controls)
        self.btn_uninhib.setObjectName("btn_uninhib")
        self.verticalLayout_2.addWidget(self.btn_uninhib)
        self.btn_inhib = QtWidgets.QPushButton(parent=self.gb_controls)
        self.btn_inhib.setObjectName("btn_inhib")
        self.verticalLayout_2.addWidget(self.btn_inhib)
        self.btn_get_sched = QtWidgets.QPushButton(parent=self.gb_controls)
        self.btn_get_sched.setObjectName("btn_get_sched")
        self.verticalLayout_2.addWidget(self.btn_get_sched)
        self.verticalLayout_3.addWidget(self.gb_controls)
        self.gb_misc = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_misc.setObjectName("gb_misc")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.gb_misc)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.btn_log = QtWidgets.QPushButton(parent=self.gb_misc)
        self.btn_log.setObjectName("btn_log")
        self.verticalLayout_8.addWidget(self.btn_log)
        self.btn_shutdown = QtWidgets.QPushButton(parent=self.gb_misc)
        self.btn_shutdown.setObjectName("btn_shutdown")
        self.verticalLayout_8.addWidget(self.btn_shutdown)
        self.btn_about = QtWidgets.QPushButton(parent=self.gb_misc)
        self.btn_about.setObjectName("btn_about")
        self.verticalLayout_8.addWidget(self.btn_about)
        self.verticalLayout_3.addWidget(self.gb_misc)
        self.gridLayout_4.addWidget(self.widget_controls, 0, 0, 1, 1)
        self.widget_status = QtWidgets.QWidget(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_status.sizePolicy().hasHeightForWidth())
        self.widget_status.setSizePolicy(sizePolicy)
        self.widget_status.setObjectName("widget_status")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.widget_status)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.gb_status = QtWidgets.QGroupBox(parent=self.widget_status)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.gb_status.sizePolicy().hasHeightForWidth())
        self.gb_status.setSizePolicy(sizePolicy)
        self.gb_status.setObjectName("gb_status")
        self.gridLayout = QtWidgets.QGridLayout(self.gb_status)
        self.gridLayout.setObjectName("gridLayout")
        self.widget = QtWidgets.QWidget(parent=self.gb_status)
        self.widget.setObjectName("widget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.widget)
        self.gridLayout_3.setContentsMargins(0, 0, 0, -1)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.gridLayout.addWidget(self.widget, 1, 0, 1, 1)
        # ADD HIDDEN LABELS HERE, UP TO 28 POSSIBLE GPIO PINS
        self.lbls_devices = []
        self.lbls_device_states = []
        for i in range( 28 ):
            self.lbls_devices.append( QtWidgets.QLabel(parent=self.widget) )
            self.lbls_devices[ i ].setText( 'DEVICE_' + str( i ) + ':' )
            self.lbls_device_states.append( QClickableLabel(parent=self.widget) )
            self.lbls_device_states[ i ].setText( 'UNKNOWN' )
            self.lbls_devices[ i ].hide()
            self.lbls_device_states[ i ].hide()
            self.gridLayout_3.addWidget(self.lbls_devices[ i ], i // 2, 2 * ( i % 2 ), 1, 1)
            self.gridLayout_3.addWidget(self.lbls_device_states[ i ], i // 2, 2 * ( i % 2 ) + 1, 1, 1)
        self.verticalLayout_6.addWidget(self.gb_status)
        self.gb_calendar = QtWidgets.QGroupBox(parent=self.widget_status)
        self.gb_calendar.setObjectName("gb_calendar")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.gb_calendar)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.cw_schedule = QPaintableCalendarWidget(parent=self.gb_calendar)
        self.cw_schedule.setGridVisible(True)
        self.cw_schedule.setHorizontalHeaderFormat(QtWidgets.QCalendarWidget.HorizontalHeaderFormat.ShortDayNames)
        self.cw_schedule.setVerticalHeaderFormat(QtWidgets.QCalendarWidget.VerticalHeaderFormat.NoVerticalHeader)
        self.cw_schedule.setNavigationBarVisible(True)
        self.cw_schedule.setDateEditEnabled(False)
        self.cw_schedule.setObjectName("cw_schedule")
        self.verticalLayout_9.addWidget(self.cw_schedule)
        self.verticalLayout_6.addWidget(self.gb_calendar)
        self.gridLayout_4.addWidget(self.widget_status, 0, 1, 1, 1)
        self.gb_output = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.gb_output.setObjectName("gb_output")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.gb_output)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.scrollArea = QtWidgets.QScrollArea(parent=self.gb_output)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 628, 300))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.text_output = QtWidgets.QTextEdit(parent=self.scrollAreaWidgetContents)
        self.text_output.setReadOnly(True)
        self.text_output.setObjectName("text_output")
        self.verticalLayout_7.addWidget(self.text_output)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout.addWidget(self.scrollArea)
        self.gridLayout_4.addWidget(self.gb_output, 1, 0, 1, 2)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Save demo mode
        self.demo_mode = demo_mode

        # Create palettes used to color labels
        self.green = QtGui.QPalette()
        self.green.setColor( QtGui.QPalette.ColorRole.WindowText, QtGui.QColor( 'green' ) )
        self.red = QtGui.QPalette()
        self.red.setColor( QtGui.QPalette.ColorRole.WindowText, QtGui.QColor( 'red' ) )
        self.black = QtGui.QPalette()
        self.black.setColor( QtGui.QPalette.ColorRole.WindowText, QtGui.QColor( 'black' ) )

        # Set the HOST and PORT default text
        self.txt_host.setText( HOST )
        self.txt_port.setText( str( PORT ) )

        # Connect host and port to connect on enter
        self.txt_host.returnPressed.connect( self.connect )
        self.txt_port.returnPressed.connect( self.connect )

        # Hide shutdown button if not in demo mode
        if not self.demo_mode:
            self.btn_shutdown.hide()

        # Disable the control interfaces until we have a connection
        self.gb_controls.setEnabled( False )
        self.gb_status.setEnabled( False )
        self.gb_calendar.setEnabled( False )
        self.btn_log.setEnabled( False )
        self.btn_shutdown.setEnabled( False )

        # Set up queues and queue locks
        self.q_in = queue.Queue()
        self.q_in_lock = QtCore.QMutex()
        self.q_out = queue.Queue()
        self.q_out_lock = QtCore.QMutex()

        # Create comm lock
        self.s_lock = QtCore.QMutex()

        # Set up thread to signal updates to GUI
        self.updater = UpdateMonitor( self.q_in, self.q_in_lock )
        self.updater.device_update_signal.connect( self.device_update )
        self.updater.print_info_signal.connect( self.text_output.append )
        self.updater.save_schedule.connect( self.save_schedule )
        self.updater.save_key.connect( self.authenticate )
        self.updater.authenticated.connect( self.authenticated )
        self.updater.start()

        # Dictionaries for generated labels and radio buttons and schedules
        self.rb_dict = {}
        self.lbl_dict = {}
        self.scheds = {}

        # Set updated flag to false
        self.updated = False

        # Connect connect button to slot
        self.btn_connect.pressed.connect( self.connect )

        # Connect shutdown button to slot
        self.btn_shutdown.pressed.connect( self.shutdown_server )

        # Initialize popup to None
        self.popup = None

        # Initialize schedule to None
        self.schedule = None

        # Connect activate button
        self.btn_activate.pressed.connect( self.activate_device )

        # Connect deactivate button
        self.btn_deactivate.pressed.connect( self.deactivate_device )

        # Connect uninhibit button
        self.btn_uninhib.pressed.connect( self.uninhibit_device )

        # Connect inhibit button
        self.btn_inhib.pressed.connect( self.inhibit_device )

        # Connect print schedules button
        self.btn_get_sched.pressed.connect( self.print_schedule )

        # Connect peak event log button
        self.btn_log.pressed.connect( self.peak_event_log )

        # Connect about button
        self.btn_about.pressed.connect( self.about )

        # Connect calendar signals
        self.cw_schedule.activated.connect( self.day_schedule_popup )
        self.cw_schedule.print_info_signal.connect( self.text_output.append )

        # Set background color of navigation bar of calendar
        self.cw_schedule.setStyleSheet( "QCalendarWidget  QWidget#qt_calendar_navigationbar"
                                        "{"
                                        "background-color : darkGray;"
                                        "}"
                                        "QCalendarWidget  QWidget# qt_calendar_navigationbar::hover"
                                        "{"
                                        "background-color : darkGray;"
                                        "}" )

        # Initialize popup to None
        self.popup = None

        # Initialize pubkey to None
        self.pubkey = None

        # Set password line edit to password mode echo
        self.txt_pswd.setEchoMode( QtWidgets.QLineEdit.EchoMode.Password )

        # Print about text
        self.about()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Remote Controller"))
        self.gb_connection.setTitle(_translate("MainWindow", "Connection"))
        self.lbl_port.setText(_translate("MainWindow", "Port:"))
        self.btn_connect.setText(_translate("MainWindow", "Connect"))
        self.lbl_host.setText(_translate("MainWindow", "Host:"))
        self.lbl_pswd.setText(_translate("MainWindow", "Password:"))
        self.gb_controls.setTitle(_translate("MainWindow", "Controls"))
        self.gb_dur.setTitle(_translate("MainWindow", "Event Duration"))
        self.cmb_dur.setPlaceholderText(_translate("MainWindow", "min"))
        self.btn_activate.setText(_translate("MainWindow", "Activate"))
        self.btn_deactivate.setText(_translate("MainWindow", "Deactivate"))
        self.btn_uninhib.setText(_translate("MainWindow", "Uninhibit"))
        self.btn_inhib.setText(_translate("MainWindow", "Inhibit"))
        self.btn_get_sched.setText(_translate("MainWindow", "Print Schedule"))
        self.gb_misc.setTitle(_translate("MainWindow", "Miscellaneous"))
        self.btn_log.setText(_translate("MainWindow", "Peak Event Log"))
        self.btn_shutdown.setText(_translate("MainWindow", "Shutdown"))
        self.btn_about.setText(_translate("MainWindow", "About"))
        self.gb_status.setTitle(_translate("MainWindow", "Status"))
        self.gb_calendar.setTitle(_translate("MainWindow", "Schedule"))
        self.gb_output.setTitle(_translate("MainWindow", "Output"))

    def connect ( self ):
        try:
            host = self.txt_host.text()
            port = int( self.txt_port.text() )
            self.s = socket.socket( socket.AF_INET, socket.SOCK_STREAM )
            self.s.settimeout( 0.5 )
            self.s.connect( ( host, port ) )
            self.s.settimeout( None )
            self.s.setblocking( 0 )

            # Create comm threads
            self.sender = Sender( self.s, self.s_lock, self.q_out, self.q_out_lock )
            self.receiver = Receiver( self.s, self.s_lock, self.q_in, self.q_in_lock )
            self.heartbeat = QtCore.QTimer()
            self.pulse_mon = QtCore.QTimer()
            self.pulse_mon.setSingleShot( True )

            # Connect signals for threads
            self.sender.lost_conn.connect( self.disconnect )
            self.receiver.lost_conn.connect( self.disconnect )
            self.receiver.server_alive.connect( self.postpone_pulse_mon )
            self.heartbeat.timeout.connect( self.get_device_updates )
            self.pulse_mon.timeout.connect( self.disconnect )

            # Start comms threads
            self.sender.start()
            self.receiver.start()
            self.pulse_mon.start( 5000 )

        except ValueError:
            self.text_output.append( 'Port is not an integer' )

        except TimeoutError:
            self.text_output.append( 'Failed to connect to host' )

        except ConnectionRefusedError:
            self.text_output.append( 'Connection was refused' )

        except socket.gaierror as e:
            self.text_output.append( str( e ) )

    def authenticate ( self, pemkey ):
        self.pubkey = rsa.PublicKey.load_pkcs1( pemkey, 'PEM' )
        password = self.txt_pswd.text().encode( 'utf-8' )
        hashword = rsa.compute_hash( password, 'SHA-1' )
        encrypted = rsa.encrypt( hashword, self.pubkey )
        container = messages.container()
        container.password = encrypted
        self.q_out_enqueue( container )

    def authenticated ( self, auth ):
        if auth:
            self.heartbeat.start( 500 )

            # If none of that raised an exception then we connected
            self.gb_connection.setEnabled( False )
            self.gb_status.setEnabled( True )
            self.gb_calendar.setEnabled( True )
            self.btn_log.setEnabled( True )
            self.btn_shutdown.setEnabled( True )
            if self.popup:
                self.popup.setEnabled( True )

            # Get device updates
            self.get_device_updates()

        else:
            self.disconnect()

    def disconnect ( self ):
        # Stop timers
        self.heartbeat.stop()

        # Disconnect heartbeat timeout
        if self.heartbeat.receivers( self.heartbeat.timeout ) > 0:
            self.heartbeat.timeout.disconnect()

        # Request comms threads stop
        self.sender.requestInterruption()
        self.receiver.requestInterruption()

        # Wait until they have stopped
        self.sender.wait()
        self.receiver.wait()

        # Disabled the interfaces for the gardener and re-enable the connection menu
        self.gb_connection.setEnabled( True )
        self.gb_controls.setEnabled( False )
        self.gb_status.setEnabled( False )
        self.gb_calendar.setEnabled( False )
        self.btn_log.setEnabled( False )
        self.btn_shutdown.setEnabled( False )
        if self.popup:
            self.popup.setEnabled( False )

        # Set the device out of date flag
        self.updated = False

        # Clear dictionaries
        self.rb_dict = {}
        self.lbl_dict = {}
        self.scheds = {}

        # Reset queues
        def empty_queue ( q ):
            while not q.empty():
                try:
                    q.get_nowait()
                except queue.Empty:
                    break
        
        self.q_in_lock.lock()
        empty_queue( self.q_in )
        self.q_in_lock.unlock()
        self.q_out_lock.lock()
        empty_queue( self.q_out )
        self.q_out_lock.unlock()

        # Shutdown and close connection, we
        # don't have to use s_lock because
        # we already joined sender_thread
        self.s.close()

    def about ( self ):
        self.text_output.append( ABOUT_STR )

    def get_device_updates ( self ):
        container = messages.container()
        container.get_states = 1
        self.q_out_enqueue( container )

    def get_schedule ( self ):
        container = messages.container()
        container.get_events = self.get_checked_output_name()
        self.q_out_enqueue( container )

    def get_checked_output_name ( self ):
        for device in self.rb_dict:
            if self.rb_dict[ device ].isChecked():
                return device

    def activate_device ( self ):
        container = messages.container()
        if self.cb_dur.isChecked():
            duration = self.sb_dur.value() * UNIT_TO_SECS[ self.cmb_dur.currentText() ]
            time_now = int( time.time() )
            container.set_event.timestamp.seconds = time_now
            container.set_event.duration.seconds = duration
            container.set_event.period.seconds = 0
            container.set_event.state.device_name = self.get_checked_output_name()
            container.set_event.state.state = messages.STATE.DEV_ACTIVE
            container.set_event.state.is_output = True
        else:
            container.set_state.device_name = self.get_checked_output_name()
            container.set_state.state = messages.STATE.DEV_ACTIVE
            container.set_state.is_output = True
        self.q_out_enqueue( container )

    def deactivate_device ( self ):
        container = messages.container()
        container.set_state.device_name = self.get_checked_output_name()
        container.set_state.state = messages.STATE.DEV_INACTIVE
        container.set_state.is_output = True
        self.q_out_enqueue( container )

    def uninhibit_device ( self ):
        container = messages.container()
        container.set_state.device_name = self.get_checked_output_name()
        container.set_state.state = messages.STATE.DEV_UNINHIBITED
        container.set_state.is_output = True
        self.q_out_enqueue( container )

    def inhibit_device ( self ):
        container = messages.container()
        if self.cb_dur.isChecked():
            duration = self.sb_dur.value() * UNIT_TO_SECS[ self.cmb_dur.currentText() ]
            time_now = int( time.time() )
            container.set_event.timestamp.seconds = time_now
            container.set_event.duration.seconds = duration
            container.set_event.period.seconds = 0
            container.set_event.state.device_name = self.get_checked_output_name()
            container.set_event.state.state = messages.STATE.DEV_INHIBITED
            container.set_event.state.is_output = True
        else:
            container.set_state.device_name = self.get_checked_output_name()
            container.set_state.state = messages.STATE.DEV_INHIBITED
            container.set_state.is_output = True
        self.q_out_enqueue( container )

    def state_to_text_and_palette ( self, state ):
        if state == messages.STATE.DEV_ACTIVE:
            return ( 'ACTIVE', self.green )
        if state == messages.STATE.DEV_INACTIVE:
            return ( 'INACTIVE', self.red )
        if state == messages.STATE.DEV_UNINHIBITED:
            return ( 'UNINHIBITED', self.black )
        if state == messages.STATE.DEV_INHIBITED:
            return ( 'INHIBITED', self.black )

    def toggle_sensor( self, device_name ):
        state = None
        if self.lbl_dict[ device_name ].text() == 'ACTIVE':
            state = messages.STATE.DEV_INACTIVE
        elif self.lbl_dict[ device_name ].text() == 'INACTIVE':
            state = messages.STATE.DEV_ACTIVE
        else:
            return
            
        container = messages.container()
        container.demo_override.device_name = device_name
        container.demo_override.state = state
        container.demo_override.is_output = False
        self.q_out_enqueue( container )

    def radio_button_pressed ( self, checked ):
        if checked:
            for device in self.rb_dict:
                if self.rb_dict[ device ].isChecked():
                    self.cw_schedule.set_schedule( self.scheds[ device ], device )
                    if self.popup:
                        self.popup.set_schedule( self.scheds[ device ], device )
                    self.print_schedule()

    def device_update ( self, device_states ):
        # Upon first update received from the server we use that info to set up our label and radio buttons
        if not self.updated:
            # Hide the devices in case out of date
            for label in self.lbls_devices: label.hide()
            for label in self.lbls_device_states:
                label.hide()
                if label.receivers( label.clicked ) > 0:
                    label.clicked.disconnect()
            for button in self.rbs_outputs:
                button.hide()
                if button.receivers( button.toggled ) > 0:
                    button.toggled.disconnect()
            # Initialize counters
            dev_count = 0
            output_count = 0
            for state in device_states.state:
                self.lbls_devices[ dev_count ].setText( state.device_name + ':' )
                self.lbls_devices[ dev_count ].show()
                self.lbls_device_states[ dev_count ].show()
                self.lbl_dict[ state.device_name ] = self.lbls_device_states[ dev_count ]
                # If in demo mode, connect to toggle slot
                if self.demo_mode and not state.is_output:
                    self.lbl_dict[ state.device_name ].set_device_name( state.device_name )
                    self.lbl_dict[ state.device_name ].clicked.connect( self.toggle_sensor )
                if state.is_output:
                    self.rbs_outputs[ output_count ].setText( state.device_name )
                    self.rbs_outputs[ output_count ].show()
                    self.rbs_outputs[ output_count ].toggled.connect( self.radio_button_pressed )
                    self.rb_dict[ state.device_name ] = self.rbs_outputs[ output_count ]
                    self.scheds[ state.device_name ] = []
                    output_count = output_count + 1
                dev_count = dev_count + 1
            if output_count > 0:
                self.rbs_outputs[ 0 ].setChecked( True )
                self.gb_controls.setEnabled( True )
                self.heartbeat.timeout.connect( self.get_schedule )
            self.updated = True
        # Normal operation, just display updated state of devices
        for state in device_states.state:
            self.lbl_dict[ state.device_name ]
            text, palette = self.state_to_text_and_palette( state.state )
            self.lbl_dict[ state.device_name ].setText( text )
            self.lbl_dict[ state.device_name ].setPalette( palette )

    def save_schedule ( self, schedule ):
        for device in self.scheds:
            dev_sched = [ event for event in schedule if event.state.device_name == device ]
            if not are_schedules_same( self.scheds[ device ], dev_sched ):
                self.scheds[ device ] = dev_sched.copy()
                if self.get_checked_output_name() == device:
                    self.cw_schedule.set_schedule( dev_sched, device )
                    if self.popup:
                        self.popup.set_schedule( dev_sched, device )
                self.print_schedule()

    def print_schedule ( self ):
        device = self.get_checked_output_name()
        schedule = self.scheds[ device ]
        self.text_output.append( device + ' EVENT SCHEDULE:' )
        if not schedule:
            self.text_output.append( 'No events scheduled!' )
        for event in schedule:
            dt = datetime.fromtimestamp( event.timestamp.seconds )
            td_dur = timedelta( seconds=event.duration.seconds )
            td_period = timedelta( seconds=event.period.seconds )
            self.text_output.append( STATE_TO_TEXT[event.state.state] + ' event scheduled for ' + str( td_dur.seconds // 60 ) + ' minute(s) on ' + str( dt ) + ' repeating every ' + str( td_period.days ) + ' day(s)' )

    def peak_event_log ( self ):
        container = messages.container()
        container.peak_logs = 10
        self.q_out_enqueue( container )

    def day_schedule_popup ( self, date ):
        dt = datetime( year=date.year(), month=date.month(), day=date.day() )
        device_name = self.get_checked_output_name()
        self.popup = DaySchedule( self.centralwidget, self.cw_schedule.schedule, dt=dt, device_name=device_name )
        self.popup.setWindowTitle( str( dt.date() ) + ' Schedule for ' + device_name )
        self.popup.send_signal.connect( self.q_out_enqueue )
        self.popup.print_info_signal.connect( self.text_output.append )
        self.popup.exec()

    def postpone_pulse_mon ( self ):
        if self.pulse_mon.isActive():
            self.pulse_mon.start( 5000 )

    def shutdown_server ( self ):
        container = messages.container()
        container.shutdown = 1
        self.q_out_enqueue( container )

    def q_out_enqueue ( self, container ):
        self.q_out_lock.lock()
        self.q_out.put( container )
        self.q_out_lock.unlock()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    if len( sys.argv ) == 3:
        if sys.argv[ 1 ] == '--demo_mode' or sys.argv[ 1 ] == '-dm':
            if sys.argv[ 2 ] == 'True':
                DEMO_MODE = True
            elif sys.argv[ 2 ] == 'False':
                DEMO_MODE = False
    ui.setupUi(MainWindow, DEMO_MODE)
    MainWindow.show()
    sys.exit(app.exec())
